<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stock Predictions - AlphaAnalytics</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
/* ---------- FULL UI CSS (updated) ---------- */
/* Core reset & fonts */
* { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Inter', sans-serif; }
:root{
  --primary-white: #ffffff;
  --bg-gradient: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
  --bg-dark: #0f0f23;
  --bg-card: rgba(30, 30, 46, 0.8);
  --bg-card-hover: rgba(40, 40, 62, 0.9);
  --text-primary: #ffffff;
  --text-secondary: #a0a0c0;
  --text-muted: #707090;
  --border-color: rgba(255,255,255,0.1);
  --hover-color: rgba(0,230,255,0.15);
  --active-color: #00e6ff;
  --up-color: #00ff9d;
  --down-color: #ff4d7c;
  --accent-blue: #00e6ff;
  --accent-teal: #00ff9d;
  --accent-purple: #8a2be2;
  --accent-pink: #ff4d7c;
  --shadow-glow: 0 0 20px rgba(0, 230, 255, 0.3);
  --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.2);
  --glass: rgba(255,255,255,0.03);
  --crisis-red: #ff4757;
  --warning-orange: #ffa502;
  --normal-green: #2ed573;
  --model-linear: #00e6ff;
  --model-ridge: #00ff9d;
  --model-lasso: #8a2be2;
  --model-svr: #ff6b6b;
  --model-rf: #ffa502;
  --model-gb: #9b59b6;
  --model-arima: #3498db;
  --model-nn: #2ecc71;
}

body.light {
  --bg-gradient: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
  --bg-dark: #ffffff;
  --bg-card: rgba(255,255,255,0.9);
  --bg-card-hover: rgba(255,255,255,1);
  --text-primary: #1e293b;
  --text-secondary: #475569;
  --text-muted: #64748b;
  --border-color: rgba(0,0,0,0.1);
  --hover-color: rgba(0,119,204,0.1);
  --active-color: #0077cc;
  --shadow-glow: 0 0 20px rgba(0, 119, 204, 0.2);
  --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.1);
  --crisis-red: #ff3838;
  --warning-orange: #ff9f1a;
  --normal-green: #00b894;
  --model-linear: #0077cc;
  --model-ridge: #00b894;
  --model-lasso: #8a2be2;
  --model-svr: #ff3838;
  --model-rf: #ff9f1a;
  --model-gb: #9b59b6;
  --model-arima: #3498db;
  --model-nn: #2ecc71;
}

html,body { height:100%; }
body {
  background: var(--bg-gradient);
  color: var(--text-primary);
  transition: all 0.4s ease;
  min-height: 100vh;
  line-height: 1.6;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}

.container {
  display:flex;
  flex-direction:column;
  min-height:100vh;
  max-width:1400px;
  margin:0 auto;
}

/* Navbar */
.navbar {
  background: rgba(15,15,35,0.9);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border-color);
  position: sticky;
  top: 0;
  z-index: 1000;
  padding: 0;
}
.nav-wrap { max-width:1400px; margin:0 auto; padding: 0 20px; }
.nav-row {
  display:flex; align-items:center; justify-content:space-between; padding:12px 0;
}
.logo {
  font-family: 'Space Grotesk', sans-serif;
  font-size:28px; font-weight:700;
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-teal));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  display:flex; align-items:center; gap:8px;
}
.logo i{ font-size:24px; }
.nav-items { display:flex; gap:8px; list-style:none; }
.nav-item {
  padding:10px 16px; border-radius:12px; color:var(--text-secondary);
  text-decoration:none; font-weight:500; font-size:14px;
  transition: all 0.3s ease; display:flex; align-items:center; gap:6px;
}
.nav-item:hover { background:var(--hover-color); color:var(--active-color); transform: translateY(-2px); }
.nav-item.active { background:var(--active-color); color:var(--bg-dark); box-shadow:var(--shadow-glow); }

.menu-toggle { display:none; flex-direction:column; gap:4px; background:none; border:none; cursor:pointer; padding:8px; }
.menu-toggle span { width:24px; height:2px; background:var(--text-primary); border-radius:2px; transition:all .3s; }

/* Mobile */
@media (max-width:768px) {
  .nav-items { display:none; position:absolute; top:100%; left:0; right:0; background:var(--bg-dark); border-top:1px solid var(--border-color); padding:16px; flex-direction:column; gap:8px; z-index:1000; }
  .nav-items.show{ display:flex; }
  .nav-item { padding:12px 16px; border-radius:8px; justify-content:flex-start; }
  .menu-toggle { display:flex; }
}

/* Main content */
.main-content {
  flex:1;
  padding:24px;
  display:flex;
  flex-direction:column;
  gap:32px;
}

/* Header */
.header { display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; flex-wrap:wrap; gap:20px; }
.header h1 { font-family:'Space Grotesk', sans-serif; font-size:32px; font-weight:700; background: linear-gradient(135deg, var(--accent-blue), var(--accent-teal)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
.header-controls { display:flex; gap:16px; align-items:center; }

/* Search bar */
.search-container { position:relative; width:400px; max-width:100%; }
.search-bar {
  width:100%; padding:14px 20px 14px 48px; background:var(--bg-card); border:1px solid var(--border-color);
  border-radius:16px; color:var(--text-primary); font-size:15px; font-weight:500; transition:all .3s; backdrop-filter: blur(10px);
}
.search-bar:focus { outline:none; border-color:var(--active-color); box-shadow:var(--shadow-glow); }
.search-icon { position:absolute; left:16px; top:50%; transform:translateY(-50%); color:var(--text-muted); font-size:18px; }

/* Buttons */
.action-buttons { display:flex; gap:12px; }
.btn { padding:12px 20px; border:none; border-radius:12px; font-weight:600; font-size:14px; cursor:pointer; display:flex; align-items:center; gap:8px; transition:all .3s; }
.btn-primary { background:var(--active-color); color:var(--bg-dark); box-shadow:var(--shadow-glow); }
.btn-secondary { background:var(--bg-card); color:var(--text-primary); border:1px solid var(--border-color); }
.btn:disabled { opacity:.6; cursor:not-allowed; transform:none !important; }

/* AI Insight */
.ai-insight { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); }
.ai-insight-header { display:flex; align-items:center; gap:12px; margin-bottom:16px; }
.ai-insight-header h3 { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; background: linear-gradient(135deg, var(--accent-blue), var(--accent-teal)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
.ai-icon { font-size:20px; color:var(--active-color); }
.ai-content { color:var(--text-primary); font-size:15px; line-height:1.6; }

/* Dashboard layout */
.prediction-dashboard { display:grid; grid-template-columns: 1fr 1fr; gap:24px; margin-bottom:32px; }
@media (max-width:900px){ .prediction-dashboard{ grid-template-columns:1fr; } }

/* Stock selector */
.stock-selector { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); transition:all .3s; position:relative; overflow:hidden; }
.stock-selector::before { content:''; position:absolute; top:0; left:0; right:0; height:3px; background: linear-gradient(90deg, var(--accent-blue), var(--accent-teal)); }
.stock-selector:hover { transform:translateY(-5px); box-shadow:var(--shadow-card); border-color:var(--active-color); }
.stock-selector h3 { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; margin-bottom:16px; }
.stock-search-container { position:relative; margin-bottom:16px; }
.stock-search { width:100%; padding:14px 20px 14px 48px; background:var(--bg-dark); border:1px solid var(--border-color); border-radius:12px; color:var(--text-primary); font-size:15px; font-weight:500; transition:all .3s; }
.stock-search:focus { outline:none; border-color:var(--active-color); box-shadow:var(--shadow-glow); }
.stock-search-icon { position:absolute; left:16px; top:50%; transform:translateY(-50%); color:var(--text-muted); font-size:18px; }
.stock-list { display:flex; flex-direction:column; gap:10px; max-height:400px; overflow-y:auto; }
.stock-item { display:flex; justify-content:space-between; align-items:center; padding:16px; background:var(--bg-dark); border-radius:12px; cursor:pointer; transition:all .3s; border:1px solid var(--border-color); }
.stock-item:hover { border-color:var(--active-color); transform:translateY(-2px); }
.stock-item.active { background:var(--active-color); color:var(--bg-dark); border-color:var(--active-color); }
.stock-info { display:flex; flex-direction:column; }
.stock-symbol { font-weight:700; font-size:16px; font-family:'Space Grotesk', sans-serif; }
.stock-name { font-size:13px; color:var(--text-secondary); margin-top:4px; }
.stock-price { font-weight:700; font-size:16px; font-family:'Space Grotesk', sans-serif; }
.price-up { color:var(--up-color); }
.price-down { color:var(--down-color); }

/* Prediction card */
.prediction-card { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); transition:all .3s; position:relative; overflow:hidden; }
.prediction-card::before { content:''; position:absolute; top:0; left:0; right:0; height:3px; background: linear-gradient(90deg, var(--accent-blue), var(--accent-teal)); }
.prediction-card:hover { transform:translateY(-5px); box-shadow:var(--shadow-card); border-color:var(--active-color); }
.prediction-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; }
.prediction-title { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; }
.prediction-actions { display:flex; gap:10px; }
.prediction-chart { height:200px; background:var(--bg-dark); border-radius:12px; margin-bottom:20px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary); border:1px solid var(--border-color); position:relative; overflow:hidden; }
.prediction-details { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
.prediction-item { display:flex; flex-direction:column; gap:6px; }
.prediction-label { font-size:13px; color:var(--text-secondary); font-weight:500; }
.prediction-value { font-size:18px; font-weight:700; font-family:'Space Grotesk', sans-serif; }
.confidence-high { color:var(--up-color); }
.confidence-medium { color:#ffa500; }
.confidence-low { color:var(--down-color); }

/* Next day predictions */
.next-day-predictions { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); margin-bottom:32px; display:none; }
.next-day-predictions h3 { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; margin-bottom:20px; background: linear-gradient(135deg, var(--accent-blue), var(--accent-teal)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
.predictions-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:16px; }
@media (max-width:900px){ .predictions-grid{ grid-template-columns:repeat(2,1fr); } }
@media (max-width:480px){ .predictions-grid{ grid-template-columns:1fr; } }
.prediction-type { background:var(--bg-dark); padding:20px; border-radius:12px; border:1px solid var(--border-color); text-align:center; }
.prediction-type-label { font-size:14px; color:var(--text-secondary); margin-bottom:8px; }
.prediction-type-value { font-size:20px; font-weight:700; font-family:'Space Grotesk', sans-serif; margin-bottom:6px; }
.prediction-type-change { font-size:14px; font-weight:600; }

/* Metrics */
.metrics-section { display:grid; grid-template-columns:repeat(4,1fr); gap:24px; margin-bottom:32px; }
@media (max-width:900px){ .metrics-section{ grid-template-columns:repeat(2,1fr); } }
@media (max-width:480px){ .metrics-section{ grid-template-columns:1fr; } }
.metric-card { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); transition:all .3s; display:flex; flex-direction:column; align-items:center; text-align:center; position:relative; overflow:hidden; }
.metric-card::before { content:''; position:absolute; top:0; left:0; right:0; height:3px; background: linear-gradient(90deg, var(--accent-blue), var(--accent-teal)); }
.metric-card:hover { transform:translateY(-5px); box-shadow:var(--shadow-card); border-color:var(--active-color); }
.metric-icon { font-size:28px; margin-bottom:12px; color:var(--active-color); }
.metric-value { font-size:32px; font-weight:700; margin-bottom:8px; font-family:'Space Grotesk', sans-serif; }
.metric-label { font-size:14px; color:var(--text-secondary); font-weight:500; }

/* Charts */
.charts-section { display:grid; grid-template-columns:1fr 1fr; gap:24px; margin-bottom:32px; }
@media (max-width:900px){ .charts-section{ grid-template-columns:1fr; } }
.chart-card { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); transition:all .3s; position:relative; overflow:hidden; }
.chart-card::before { content:''; position:absolute; top:0; left:0; right:0; height:3px; background: linear-gradient(90deg, var(--accent-blue), var(--accent-teal)); }
.chart-card:hover { transform:translateY(-5px); box-shadow:var(--shadow-card); border-color:var(--active-color); }
.chart-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; }
.chart-title { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; }
.chart-actions select { padding:8px 12px; background:var(--bg-dark); border:1px solid var(--border-color); border-radius:8px; color:var(--text-primary); font-size:14px; font-weight:500; }
.chart-container { height:250px; background:var(--bg-dark); border-radius:12px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary); border:1px solid var(--border-color); position:relative; overflow:hidden; }

/* Performance & Confidence */
.performance-section { display:grid; grid-template-columns:1fr 1fr; gap:24px; margin-bottom:32px; }
@media (max-width:900px){ .performance-section{ grid-template-columns:1fr; } }

.performance-card { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); }
.performance-card h3 { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; margin-bottom:20px; background: linear-gradient(135deg, var(--accent-blue), var(--accent-teal)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }

.performance-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:16px; }
.performance-item { background:var(--bg-dark); padding:16px; border-radius:12px; border:1px solid var(--border-color); }
.performance-label { font-size:12px; color:var(--text-secondary); margin-bottom:6px; }
.performance-value { font-size:16px; font-weight:700; font-family:'Space Grotesk', sans-serif; }
.performance-subtext { font-size:11px; color:var(--text-muted); margin-top:4px; }

.confidence-bars { display:flex; flex-direction:column; gap:12px; }
.confidence-bar { display:flex; align-items:center; gap:12px; }
.confidence-label { width:80px; font-size:13px; color:var(--text-secondary); }
.confidence-track { flex:1; height:8px; background:var(--border-color); border-radius:4px; overflow:hidden; }
.confidence-fill { height:100%; border-radius:4px; transition:width 0.5s ease; }
.confidence-value { width:50px; text-align:right; font-size:13px; font-weight:600; }

/* Algorithm Breakdown Section */
.algorithm-section { display:block; margin-bottom:32px; }

.algorithm-tabs { display:flex; gap:8px; margin-bottom:20px; flex-wrap:wrap; }
.algorithm-tab { padding:10px 16px; background:var(--bg-dark); border:1px solid var(--border-color); border-radius:8px; font-size:14px; font-weight:600; cursor:pointer; transition:all 0.3s; }
.algorithm-tab:hover { border-color:var(--active-color); }
.algorithm-tab.active { background:var(--active-color); color:var(--bg-dark); border-color:var(--active-color); box-shadow:var(--shadow-glow); }

.algorithm-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(350px, 1fr)); gap:20px; }
.algorithm-card { background:var(--bg-card); border-radius:16px; padding:20px; border:1px solid var(--border-color); position: relative; }
.algorithm-card-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; }
.algorithm-name { font-size:16px; font-weight:700; font-family:'Space Grotesk', sans-serif; }
.algorithm-confidence { font-size:14px; font-weight:600; padding:4px 12px; border-radius:20px; }
.algorithm-confidence.high { background:rgba(0, 255, 157, 0.2); color:var(--up-color); }
.algorithm-confidence.medium { background:rgba(255, 165, 0, 0.2); color:#ffa500; }
.algorithm-confidence.low { background:rgba(255, 77, 124, 0.2); color:var(--down-color); }

.algorithm-predictions { display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; margin-bottom:16px; }
@media (max-width:768px){ .algorithm-predictions{ grid-template-columns:repeat(2, 1fr); } }
.algorithm-prediction-item { background:var(--bg-dark); padding:12px; border-radius:8px; border:1px solid var(--border-color); text-align:center; }
.algorithm-prediction-label { font-size:11px; color:var(--text-secondary); margin-bottom:4px; }
.algorithm-prediction-value { font-size:14px; font-weight:700; font-family:'Space Grotesk', sans-serif; }
.algorithm-prediction-change { font-size:11px; font-weight:600; }

.algorithm-performance { margin-top:16px; padding-top:16px; border-top:1px solid var(--border-color); }
.algorithm-performance-grid { display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; }
.algorithm-performance-item { text-align:center; }
.algorithm-performance-label { font-size:9px; color:var(--text-muted); margin-bottom:2px; }
.algorithm-performance-value { font-size:10px; font-weight:700; }

/* Model Comparison Table */
.model-comparison-section { display:block; margin-bottom:32px; }
.model-comparison-table { width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; }
.model-comparison-table th { background: var(--bg-dark); padding: 12px 16px; text-align: left; font-size: 13px; font-weight: 600; color: var(--text-secondary); border-bottom: 1px solid var(--border-color); }
.model-comparison-table td { padding: 12px 16px; border-bottom: 1px solid var(--border-color); font-size: 13px; }
.model-comparison-table tr:hover { background: var(--hover-color); }
.model-comparison-table .model-name { font-weight: 600; color: var(--text-primary); }
.model-comparison-table .performance-score { font-weight: 700; font-family: 'Space Grotesk', sans-serif; }
.model-comparison-table .rank-badge { padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
.model-comparison-table .rank-1 { background: rgba(255, 215, 0, 0.2); color: #ffd700; }
.model-comparison-table .rank-2 { background: rgba(192, 192, 192, 0.2); color: #c0c0c0; }
.model-comparison-table .rank-3 { background: rgba(205, 127, 50, 0.2); color: #cd7f32; }

/* Detailed Model View */
.detailed-model-section { display:grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 24px; margin-bottom:32px; }
.detailed-model-card { background: var(--bg-card); border-radius: 16px; padding: 20px; border: 1px solid var(--border-color); }
.detailed-model-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
.detailed-model-title { font-size: 18px; font-weight: 700; font-family: 'Space Grotesk', sans-serif; }
.detailed-model-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 20px; }
.detailed-model-stat { background: var(--bg-dark); padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); }
.detailed-model-stat-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
.detailed-model-stat-value { font-size: 16px; font-weight: 700; font-family: 'Space Grotesk', sans-serif; }
.detailed-model-predictions { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
.detailed-model-prediction { background: var(--bg-dark); padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); }
.detailed-model-prediction-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
.detailed-model-prediction-value { font-size: 16px; font-weight: 700; font-family: 'Space Grotesk', sans-serif; }

/* Crisis & Market Regime */
.crisis-section { display:grid; grid-template-columns:1fr 1fr; gap:24px; margin-bottom:32px; }
@media (max-width:900px){ .crisis-section{ grid-template-columns:1fr; } }

.crisis-card { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); position:relative; overflow:hidden; }
.crisis-card.critical { border-color:var(--crisis-red); }
.crisis-card.warning { border-color:var(--warning-orange); }
.crisis-card.normal { border-color:var(--normal-green); }

.crisis-card h3 { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; margin-bottom:16px; }
.crisis-card.critical h3 { color:var(--crisis-red); }
.crisis-card.warning h3 { color:var(--warning-orange); }
.crisis-card.normal h3 { color:var(--normal-green); }

.crisis-indicator { display:flex; align-items:center; gap:12px; margin-bottom:16px; }
.crisis-icon { font-size:24px; }
.crisis-level { font-size:20px; font-weight:700; }
.crisis-probability { font-size:28px; font-weight:700; margin:16px 0; }
.crisis-description { font-size:14px; color:var(--text-secondary); line-height:1.5; }

.regime-indicators { display:grid; grid-template-columns:repeat(2,1fr); gap:12px; }
.regime-indicator { display:flex; align-items:center; gap:8px; padding:12px; background:var(--bg-dark); border-radius:8px; border:1px solid var(--border-color); }
.regime-icon { font-size:16px; }
.regime-text { font-size:13px; }

/* Risk Alerts */
.risk-alerts { background:var(--bg-card); border-radius:20px; padding:24px; border:1px solid var(--border-color); backdrop-filter: blur(10px); margin-bottom:32px; display:none; }
.risk-alerts h3 { font-family:'Space Grotesk', sans-serif; font-size:18px; font-weight:700; margin-bottom:20px; color:var(--crisis-red); }
.alert-list { display:flex; flex-direction:column; gap:12px; }
.alert-item { display:flex; align-items:flex-start; gap:12px; padding:16px; background:var(--bg-dark); border-radius:12px; border-left:4px solid var(--crisis-red); }
.alert-item.warning { border-left-color:var(--warning-orange); }
.alert-item.info { border-left-color:var(--accent-blue); }
.alert-icon { font-size:18px; margin-top:2px; }
.alert-content { flex:1; }
.alert-level { font-size:14px; font-weight:700; margin-bottom:4px; }
.alert-message { font-size:13px; color:var(--text-secondary); margin-bottom:4px; }
.alert-action { font-size:12px; color:var(--text-muted); }

/* Loading & iframe removed (we removed Dash iframe) */
.loading-overlay { display:none; }

/* Shimmer */
.shimmer { background: linear-gradient(90deg, var(--bg-dark) 25%, var(--bg-card) 50%, var(--bg-dark) 75%); background-size:200% 100%; animation: shimmer 1.5s infinite; border-radius:4px; }
@keyframes shimmer { 0%{ background-position:-200% 0; } 100%{ background-position:200% 0; } }

/* Notification */
.notification { position: fixed; top:20px; right:20px; padding:16px 20px; border-radius:12px; background:var(--bg-card); border:1px solid var(--border-color); backdrop-filter: blur(10px); z-index:10000; transform:translateX(400px); transition: transform .3s ease; max-width:400px; }
.notification.show { transform:translateX(0); }
.notification.success { border-color: var(--up-color); }
.notification.error { border-color: var(--down-color); }
.notification-content { display:flex; align-items:center; gap:12px; }
.notification-icon { font-size:20px; }
.notification.success .notification-icon { color:var(--up-color); }
.notification.error .notification-icon { color:var(--down-color); }
.notification-message { flex:1; font-size:14px; font-weight:500; }

/* Responsive tweaks */
@media (max-width:768px){
  .navbar { padding:0 16px; }
  .nav-row { flex-wrap:wrap; }
  .main-content { padding:16px; }
  .header { flex-direction:column; align-items:flex-start; }
  .header-controls { width:100%; justify-content:space-between; }
  .search-container { width:100%; }
  .performance-grid { grid-template-columns:1fr; }
  .regime-indicators { grid-template-columns:1fr; }
  .algorithm-grid { grid-template-columns:1fr; }
  .algorithm-predictions { grid-template-columns:1fr; }
  .detailed-model-section { grid-template-columns: 1fr; }
}
@media (max-width:480px){
  .prediction-card, .stock-selector, .metric-card, .chart-card, .next-day-predictions { padding:20px; }
  .performance-card, .crisis-card { padding:20px; }
  .algorithm-predictions { grid-template-columns: repeat(2, 1fr); }
}
</style>
</head>
<body>
<div class="container">
  <!-- NAVBAR -->
  <header class="navbar">
    <div class="nav-wrap">
      <div class="nav-row">
        <div class="logo"><i class="fas fa-chart-line"></i> AlphaAnalytics</div>
        <button class="menu-toggle" aria-label="Toggle menu"><span></span><span></span><span></span></button>
        <nav class="nav-items">
          <a href="/jeet" class="nav-item"><i class="fas fa-home"></i>Dashboard</a>
          <a href="/portfolio" class="nav-item"><i class="fas fa-briefcase"></i>Portfolio</a>
          <a href="/mystock" class="nav-item"><i class="fas fa-star"></i>My Stock</a>
          <a href="/deposit" class="nav-item"><i class="fas fa-wallet"></i>Deposit</a>
          <a href="/insight" class="nav-item"><i class="fas fa-brain"></i>Insight</a>
          <a href="/prediction" class="nav-item active"><i class="fas fa-crystal-ball"></i>Prediction</a>
          <a href="/news" class="nav-item"><i class="fas fa-newspaper"></i>News</a>
          <a href="/videos" class="nav-item"><i class="fas fa-play-circle"></i>Videos</a>
          <a href="/Superstars" class="nav-item"><i class="fas fa-trophy"></i>Superstars</a>
          <a href="/alerts" class="nav-item"><i class="fas fa-bell"></i>Alerts</a>
          <a href="/help" class="nav-item"><i class="fas fa-question-circle"></i>Help</a>
          <a href="/profile" class="nav-item"><i class="fas fa-user"></i>Profile</a>
        </nav>
      </div>
    </div>
  </header>

  <!-- Notification -->
  <div class="notification" id="notification">
    <div class="notification-content">
      <i class="fas fa-check-circle notification-icon"></i>
      <div class="notification-message" id="notificationMessage">Operation completed successfully!</div>
    </div>
  </div>

  <!-- MAIN -->
  <main class="main-content">
    <div class="header">
      <h1>AI Stock Predictions</h1>
      <div class="header-controls">
        <div class="search-container">
          <i class="fas fa-search search-icon"></i>
          <input id="globalSearch" class="search-bar" placeholder="Search predictions..." />
        </div>
        <div class="action-buttons">
          <button class="btn btn-primary" id="generateAllBtn"><i class="fas fa-bolt"></i>Generate All</button>
          <button class="btn btn-secondary" id="themeBtn"><i class="fas fa-palette"></i>Theme</button>
        </div>
      </div>
    </div>

    <div class="ai-insight">
      <div class="ai-insight-header">
        <i class="fas fa-robot ai-icon"></i>
        <h3>AI Prediction Engine</h3>
      </div>
      <div class="ai-content" id="aiInsightText">
        Our AI analyzes 10 years of historical data using 8 algorithms (Linear Regression, Ridge, Lasso, SVR, Random Forest, Gradient Boosting, ARIMA, Neural Network) with 90+ technical features to generate next-day OCHL predictions.
      </div>
    </div>

    <!-- Risk Alerts -->
    <div class="risk-alerts" id="riskAlerts">
      <h3><i class="fas fa-exclamation-triangle"></i> Risk Alerts</h3>
      <div class="alert-list" id="alertList"></div>
    </div>

    <!-- Metrics -->
    <div class="metrics-section">
      <div class="metric-card">
        <div class="metric-icon"><i class="fas fa-bullseye"></i></div>
        <div class="metric-value" id="metricAccuracy">â€”</div>
        <div class="metric-label">Prediction Accuracy</div>
      </div>
      <div class="metric-card">
        <div class="metric-icon"><i class="fas fa-trophy"></i></div>
        <div class="metric-value" id="metricProfit">â€”</div>
        <div class="metric-label">Profitable Predictions</div>
      </div>
      <div class="metric-card">
        <div class="metric-icon"><i class="fas fa-bolt"></i></div>
        <div class="metric-value" id="metricLatency">â€”</div>
        <div class="metric-label">Avg. Processing Time</div>
      </div>
      <div class="metric-card">
        <div class="metric-icon"><i class="fas fa-database"></i></div>
        <div class="metric-value" id="metricHistory">â€”</div>
        <div class="metric-label">Historical Data</div>
      </div>
    </div>

    <!-- Crisis & Market Regime -->
    <div class="crisis-section">
      <div class="crisis-card normal" id="crisisCard">
        <h3><i class="fas fa-shield-alt"></i> Market Crisis Detection</h3>
        <div class="crisis-indicator">
          <i class="fas fa-check-circle crisis-icon" style="color:var(--normal-green)"></i>
          <div class="crisis-level">Normal Market Conditions</div>
        </div>
        <div class="crisis-probability" id="crisisProbability">10%</div>
        <div class="crisis-description" id="crisisDescription">Market conditions appear stable with normal volatility levels.</div>
      </div>

      <div class="crisis-card normal" id="regimeCard">
        <h3><i class="fas fa-chart-line"></i> Market Regime</h3>
        <div class="crisis-indicator">
          <i class="fas fa-chart-bar crisis-icon" style="color:var(--normal-green)"></i>
          <div class="crisis-level" id="regimeLevel">NORMAL</div>
        </div>
        <div class="regime-indicators">
          <div class="regime-indicator">
            <i class="fas fa-wave-square regime-icon"></i>
            <div class="regime-text" id="volatilityIndicator">Volatility: Normal</div>
          </div>
          <div class="regime-indicator">
            <i class="fas fa-tachometer-alt regime-icon"></i>
            <div class="regime-text" id="momentumIndicator">Momentum: Neutral</div>
          </div>
          <div class="regime-indicator">
            <i class="fas fa-volume-up regime-icon"></i>
            <div class="regime-text" id="volumeIndicator">Volume: Average</div>
          </div>
          <div class="regime-indicator">
            <i class="fas fa-balance-scale regime-icon"></i>
            <div class="regime-text" id="sentimentIndicator">Sentiment: Balanced</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Next Day Predictions -->
    <div class="next-day-predictions" id="nextDayPredictions">
      <h3 id="nextDayHeader">ðŸ“ˆ Next Day Price Predictions</h3>
      <div class="predictions-grid" id="predictionsGrid"></div>
    </div>

    <!-- Prediction Dashboard -->
    <div class="prediction-dashboard">
      <!-- Stock Selector -->
      <div class="stock-selector">
        <h3>Select Stock</h3>
        <div class="stock-search-container">
          <i class="fas fa-search stock-search-icon"></i>
          <input id="stockSearch" class="stock-search" placeholder="Search stocks..." />
        </div>
        <div class="stock-list" id="stockList">
          <!-- Filled by JS -->
        </div>
      </div>

      <!-- Prediction Card -->
      <div class="prediction-card">
        <div class="prediction-header">
          <div class="prediction-title" id="selectedStock">SPY - SPDR S&P 500 ETF</div>
          <div class="prediction-actions">
            <button class="btn btn-secondary" id="refreshBtn"><i class="fas fa-sync-alt"></i>Refresh</button>
            <button class="btn btn-primary" id="predictBtn"><i class="fas fa-chart-line"></i>Predict</button>
            <button class="btn btn-secondary" id="trainBtn"><i class="fas fa-brain"></i>Train</button>
          </div>
        </div>

        <div class="prediction-chart" id="predictionChart">
          <div>Select a stock and click Predict to generate AI-powered forecasts</div>
        </div>

        <div class="prediction-details">
          <div class="prediction-item">
            <div class="prediction-label">Current Price</div>
            <div class="prediction-value" id="currentPrice">â€”</div>
          </div>
          <div class="prediction-item">
            <div class="prediction-label">Predicted Close</div>
            <div class="prediction-value" id="predictedPrice">â€”</div>
          </div>
          <div class="prediction-item">
            <div class="prediction-label">Confidence</div>
            <div class="prediction-value confidence-high" id="confidenceLevel">â€”</div>
          </div>
          <div class="prediction-item">
            <div class="prediction-label">Time Horizon</div>
            <div class="prediction-value" id="timeHorizon">Next Day</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Algorithm Breakdown Section -->
    <div class="algorithm-section" id="algorithmSection">
      <div class="performance-card">
        <h3><i class="fas fa-microchip"></i> All Algorithm Predictions Breakdown</h3>
        <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
          See how each of the 8 algorithms predicts OCHL (Open, Close, High, Low) values with individual confidence scores
        </p>
        
        <div class="algorithm-tabs" id="algorithmTabs">
          <!-- Tabs will be generated by JavaScript -->
        </div>
        
        <div class="algorithm-grid" id="algorithmGrid">
          <!-- Algorithm cards will be generated by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Model Comparison Table -->
    <div class="model-comparison-section" id="modelComparisonSection">
      <div class="performance-card">
        <h3><i class="fas fa-chart-bar"></i> Model Performance Comparison</h3>
        <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
          Detailed performance metrics across all 8 algorithms for the selected stock
        </p>
        
        <div class="table-container" style="overflow-x: auto;">
          <table class="model-comparison-table">
            <thead>
              <tr id="modelComparisonHeader">
                <!-- Will be populated by JavaScript -->
              </tr>
            </thead>
            <tbody id="modelComparisonBody">
              <!-- Will be populated by JavaScript -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Detailed Model Views -->
    <div class="detailed-model-section" id="detailedModelSection">
      <!-- Will be populated by JavaScript -->
    </div>

    <!-- Performance & Confidence -->
    <div class="performance-section">
      <div class="performance-card">
        <h3><i class="fas fa-chart-bar"></i> Historical Performance</h3>
        <div class="performance-grid" id="performanceGrid">
          <div class="performance-item">
            <div class="performance-label">Best Model RÂ² Score</div>
            <div class="performance-value" id="r2Score">â€”</div>
            <div class="performance-subtext">Higher is better</div>
          </div>
          <div class="performance-item">
            <div class="performance-label">Direction Accuracy</div>
            <div class="performance-value" id="directionAccuracy">â€”</div>
            <div class="performance-subtext">Price movement prediction</div>
          </div>
          <div class="performance-item">
            <div class="performance-label">Best Model RMSE</div>
            <div class="performance-value" id="rmseScore">â€”</div>
            <div class="performance-subtext">Lower is better</div>
          </div>
          <div class="performance-item">
            <div class="performance-label">Algorithms Used</div>
            <div class="performance-value" id="algorithmsUsed">â€”</div>
            <div class="performance-subtext">Active models</div>
          </div>
        </div>
      </div>

      <div class="performance-card">
        <h3><i class="fas fa-chart-pie"></i> Prediction Confidence</h3>
        <div class="confidence-bars" id="confidenceBars">
          <div class="confidence-bar">
            <div class="confidence-label">Open</div>
            <div class="confidence-track">
              <div class="confidence-fill" style="width: 0%; background: var(--accent-blue)"></div>
            </div>
            <div class="confidence-value">â€”</div>
          </div>
          <div class="confidence-bar">
            <div class="confidence-label">High</div>
            <div class="confidence-track">
              <div class="confidence-fill" style="width: 0%; background: var(--accent-teal)"></div>
            </div>
            <div class="confidence-value">â€”</div>
          </div>
          <div class="confidence-bar">
            <div class="confidence-label">Low</div>
            <div class="confidence-track">
              <div class="confidence-fill" style="width: 0%; background: var(--accent-purple)"></div>
            </div>
            <div class="confidence-value">â€”</div>
          </div>
          <div class="confidence-bar">
            <div class="confidence-label">Close</div>
            <div class="confidence-track">
              <div class="confidence-fill" style="width: 0%; background: var(--up-color)"></div>
            </div>
            <div class="confidence-value">â€”</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Charts -->
    <div class="charts-section">
      <div class="chart-card">
        <div class="chart-header">
          <div class="chart-title">Historical Performance</div>
          <div class="chart-actions">
            <select id="historyRange">
              <option>1 Month</option>
              <option>3 Months</option>
              <option>1 Year</option>
              <option selected>10 Years</option>
            </select>
          </div>
        </div>
        <div class="chart-container" id="historicalChart">Historical performance chart will appear here</div>
      </div>

      <div class="chart-card">
        <div class="chart-header">
          <div class="chart-title">Model Performance Comparison</div>
          <div class="chart-actions">
            <select id="modelComparisonFilter">
              <option>All Models</option>
              <option>Top 3 Models</option>
              <option selected>By RÂ² Score</option>
              <option>By Direction Accuracy</option>
            </select>
          </div>
        </div>
        <div class="chart-container" id="modelChart">Model comparison chart will appear here</div>
      </div>
    </div>

    <!-- Model / Disclaimer -->
    <div class="card" style="padding:20px; background:var(--bg-card); border-radius:20px; border:1px solid var(--border-color);">
      <h3 style="color:var(--accent-blue); margin-bottom:8px">Model & Deployment</h3>
      <p style="color:var(--text-secondary); font-size:14px; line-height:1.5;">
        This AI prediction system uses 8 advanced machine learning models (Linear Regression, Ridge, Lasso, SVR, Random Forest, Gradient Boosting, ARIMA, Neural Network) with 10 years of historical data, 90+ technical features, and real-time confidence scoring. All predictions are for educational purposes only.
      </p>
    </div>

  </main>
</div>

<script>
/* =============== ENHANCED PREDICTION UI SCRIPT =============== */
/* Shows which algorithm gives what prediction for OCHL values */

const CONFIG = {
  API_BASE_URL: window.location.origin,
  DEBOUNCE_DELAY: 300,
  NOTIFICATION_DURATION: 4500,
  STOCK_REFRESH_INTERVAL: 300000 // 5 minutes
};

const AppState = {
  allStocks: [],
  selectedStock: null,
  isGenerating: false,
  currentPredictions: null,
  lastFetchTime: null,
  marketStatus: "unknown",
  activeAlgorithmTab: 'all',
  allAlgorithms: [
    'linear_regression',
    'ridge',
    'lasso',
    'svr',
    'random_forest',
    'gradient_boosting',
    'arima',
    'neural_network'
  ],
  algorithmNames: {
    'linear_regression': 'Linear Regression',
    'ridge': 'Ridge Regression',
    'lasso': 'Lasso Regression',
    'svr': 'Support Vector Regression',
    'random_forest': 'Random Forest',
    'gradient_boosting': 'Gradient Boosting',
    'arima': 'ARIMA',
    'neural_network': 'Neural Network'
  },
  algorithmColors: {
    'linear_regression': 'var(--model-linear)',
    'ridge': 'var(--model-ridge)',
    'lasso': 'var(--model-lasso)',
    'svr': 'var(--model-svr)',
    'random_forest': 'var(--model-rf)',
    'gradient_boosting': 'var(--model-gb)',
    'arima': 'var(--model-arima)',
    'neural_network': 'var(--model-nn)'
  }
};

/* Mobile menu handler */
class MobileMenu {
  constructor() {
    this.menuToggle = document.querySelector('.menu-toggle');
    this.navItems = document.querySelector('.nav-items');
    this.isOpen = false;
    this.init();
  }
  
  init() {
    if (this.menuToggle && this.navItems) {
      this.menuToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        this.toggle();
      });
      
      document.addEventListener('click', (event) => {
        if (this.isOpen && !event.target.closest('.navbar')) {
          this.close();
        }
      });
    }
  }
  
  toggle() { 
    this.isOpen = !this.isOpen; 
    this.navItems.classList.toggle('show'); 
    const spans = this.menuToggle.querySelectorAll('span'); 
    spans.forEach(s => s.classList.toggle('active')); 
  }
  
  close() { 
    this.isOpen = false; 
    this.navItems.classList.remove('show'); 
    const spans = this.menuToggle.querySelectorAll('span'); 
    spans.forEach(s => s.classList.remove('active')); 
  }
}

/* Notification system */
class NotificationManager {
  static show(message, type = 'success') {
    const n = document.getElementById('notification');
    const msg = document.getElementById('notificationMessage');
    
    if (!n || !msg) { 
      console.log(`${type.toUpperCase()}: ${message}`); 
      return; 
    }
    
    msg.textContent = message;
    n.className = `notification ${type}`;
    n.classList.add('show');
    
    const icon = n.querySelector('.notification-icon');
    if (type === 'success') {
      icon.className = 'fas fa-check-circle notification-icon';
    } else {
      icon.className = 'fas fa-exclamation-circle notification-icon';
    }
    
    setTimeout(() => n.classList.remove('show'), CONFIG.NOTIFICATION_DURATION);
  }
}

/* API Service for Flask backend */
class StockAPIService {
  static async fetchStocks() {
    try {
      const res = await fetch(`${CONFIG.API_BASE_URL}/api/stocks`);
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      return await res.json();
    } catch (err) {
      console.error('Fetch stocks error:', err);
      NotificationManager.show('Using cached stock list', 'error');
      return this.getFallbackStocks();
    }
  }

  static async predict(symbol) {
    try {
      const res = await fetch(`${CONFIG.API_BASE_URL}/api/predict`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ symbol })
      });
      
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Prediction failed: ${res.status} ${errorText}`);
      }
      
      return await res.json();
    } catch (err) {
      console.error('Prediction error:', err);
      throw err;
    }
  }

  static async trainModels(symbol) {
    try {
      const res = await fetch(`${CONFIG.API_BASE_URL}/api/train`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ symbol })
      });
      
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Training failed: ${res.status} ${errorText}`);
      }
      
      return await res.json();
    } catch (err) {
      console.error('Training error:', err);
      throw err;
    }
  }

  static async getPredictionHistory(symbol) {
    try {
      const res = await fetch(`${CONFIG.API_BASE_URL}/api/history/${symbol}`);
      if (!res.ok) throw new Error(`History error: ${res.status}`);
      return await res.json();
    } catch (err) {
      console.error('History error:', err);
      return null;
    }
  }

  static getFallbackStocks() {
    return [
      { symbol: "AAPL", name: "Apple Inc.", price: 182.63, change: 1.24 },
      { symbol: "MSFT", name: "Microsoft Corp.", price: 407.57, change: -0.85 },
      { symbol: "GOOGL", name: "Alphabet Inc.", price: 172.34, change: 2.13 },
      { symbol: "AMZN", name: "Amazon.com Inc.", price: 178.22, change: 0.67 },
      { symbol: "TSLA", name: "Tesla Inc.", price: 175.79, change: -3.21 },
      { symbol: "META", name: "Meta Platforms Inc.", price: 485.58, change: 1.89 },
      { symbol: "NVDA", name: "NVIDIA Corp.", price: 950.02, change: 5.42 },
      { symbol: "SPY", name: "SPDR S&P 500 ETF", price: 445.20, change: 0.45 },
      { symbol: "QQQ", name: "Invesco QQQ Trust", price: 378.90, change: 0.67 },
      { symbol: "JPM", name: "JPMorgan Chase & Co.", price: 195.18, change: -0.32 }
    ];
  }
}

/* Stock List Manager */
class StockListManager {
  constructor() {
    this.stockListEl = document.getElementById('stockList');
    this.searchEl = document.getElementById('stockSearch');
    this.debounced = this.debounce(this.filterList.bind(this), CONFIG.DEBOUNCE_DELAY);
    this.init();
  }

  init() {
    if (this.searchEl) {
      this.searchEl.addEventListener('input', this.debounced);
    }
  }

  async populate() {
    if (!this.stockListEl) return;
    
    this.stockListEl.innerHTML = `
      <div class="shimmer" style="height: 60px; margin-bottom: 10px;"></div>
      <div class="shimmer" style="height: 60px; margin-bottom: 10px;"></div>
      <div class="shimmer" style="height: 60px; margin-bottom: 10px;"></div>
    `;
    
    AppState.allStocks = await StockAPIService.fetchStocks();
    this.render();
    
    if (AppState.allStocks.length > 0) {
      this.select(AppState.allStocks[0]);
    }
  }

  render() {
    this.stockListEl.innerHTML = '';
    AppState.allStocks.forEach(stock => {
      this.stockListEl.appendChild(this.createStockItem(stock));
    });
  }

  createStockItem(stock) {
    const item = document.createElement('div');
    item.className = 'stock-item';
    
    const change = stock.change || 0;
    const price = stock.price || 0;
    
    item.innerHTML = `
      <div class="stock-info">
        <div class="stock-symbol">${stock.symbol}</div>
        <div class="stock-name">${stock.name}</div>
      </div>
      <div class="stock-price ${change >= 0 ? 'price-up' : 'price-down'}">
        $${price.toFixed(2)} 
        <span>${change >= 0 ? '+' : ''}${change.toFixed(2)}%</span>
      </div>
    `;
    
    item.addEventListener('click', () => this.select(stock));
    return item;
  }

  select(stock) {
    // Remove active class from all items
    document.querySelectorAll('.stock-item').forEach(i => i.classList.remove('active'));
    
    // Find and activate selected item
    const items = Array.from(document.querySelectorAll('.stock-item'));
    const foundItem = items.find(i => {
      const symbolEl = i.querySelector('.stock-symbol');
      return symbolEl && symbolEl.textContent === stock.symbol;
    });
    
    if (foundItem) {
      foundItem.classList.add('active');
    }
    
    AppState.selectedStock = stock;
    document.getElementById('selectedStock').textContent = `${stock.symbol} - ${stock.name}`;
    
    // Update current price display
    const currentPriceEl = document.getElementById('currentPrice');
    if (currentPriceEl) {
      currentPriceEl.textContent = `$${(stock.price || 0).toFixed(2)}`;
    }
    
    // Reset prediction display
    PredictionDisplay.reset();
  }

  filterList(e) {
    const query = (e.target.value || '').toLowerCase().trim();
    
    document.querySelectorAll('.stock-item').forEach(item => {
      const symbol = item.querySelector('.stock-symbol')?.textContent?.toLowerCase() || '';
      const name = item.querySelector('.stock-name')?.textContent?.toLowerCase() || '';
      
      if (symbol.includes(query) || name.includes(query)) {
        item.style.display = 'flex';
      } else {
        item.style.display = 'none';
      }
    });
  }

  debounce(fn, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn.apply(this, args), wait);
    };
  }
}

/* Comprehensive Prediction Display */
class PredictionDisplay {
  static reset() {
    // Reset main prediction display
    const elements = {
      'predictedPrice': 'â€”',
      'confidenceLevel': 'â€”',
      'currentPrice': 'â€”'
    };
    
    Object.keys(elements).forEach(id => {
      const el = document.getElementById(id);
      if (el) el.textContent = elements[id];
    });
    
    // Reset chart
    const chartEl = document.getElementById('predictionChart');
    if (chartEl) {
      chartEl.innerHTML = `
        <div style="padding: 40px; text-align: center; color: var(--text-muted);">
          <i class="fas fa-chart-line" style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;"></i>
          <div>Select a stock and click "Predict" to generate AI-powered forecasts</div>
        </div>
      `;
    }
    
    // Hide sections
    this.hideNextDayPredictions();
    this.hideRiskAlerts();
    this.hideAlgorithmSection();
    this.resetPerformance();
    this.resetCrisisDetection();
    this.resetMetrics();
    
    // Reset confidence bars
    document.querySelectorAll('.confidence-fill').forEach(el => {
      el.style.width = '0%';
    });
    
    document.querySelectorAll('.confidence-value').forEach(el => {
      el.textContent = 'â€”';
    });
    
    // Clear algorithm sections
    document.getElementById('algorithmGrid').innerHTML = '';
    document.getElementById('modelComparisonBody').innerHTML = '';
    document.getElementById('detailedModelSection').innerHTML = '';
  }

  static update(data) {
    if (!data) return;
    
    console.log('Prediction data received:', data);
    
    // Store current predictions
    AppState.currentPredictions = data;
    AppState.lastFetchTime = new Date();
    
    // Update current prices
    const currentPrices = data.current_prices || {};
    document.getElementById('currentPrice').textContent = 
      `$${(currentPrices.close || data.current_prices?.close || 0).toFixed(2)}`;
    
    // Update predictions
    const predictions = data.predictions || {};
    this.updatePredictions(predictions, currentPrices.close || 0);
    
    // Update confidence
    const confidence = data.confidence_metrics || {};
    this.updateConfidence(confidence);
    
    // Update AI insight
    this.updateInsight(data.insight || data.message || 'AI analysis completed.');
    
    // Update charts
    this.updateChart(data);
    
    // Update next day predictions
    this.updateNextDayPredictions(predictions, currentPrices);
    
    // Update algorithm breakdown
    this.updateAlgorithmBreakdown(data);
    
    // Update model comparison table
    this.updateModelComparison(data);
    
    // Update detailed model views
    this.updateDetailedModelViews(data);
    
    // Update performance metrics
    this.updatePerformance(data.historical_performance || {});
    
    // Update confidence bars
    this.updateConfidenceBars(predictions);
    
    // Update crisis detection
    this.updateCrisisDetection(data);
    
    // Update risk alerts
    this.updateRiskAlerts(data.risk_alerts || []);
    
    // Update metrics
    this.updateMetrics(data);
    
    // Update risk level and recommendation
    this.updateRiskAndRecommendation(data);
  }

  static updatePredictions(predictions, currentClose) {
    if (!predictions.Close) return;
    
    const predictedClose = predictions.Close.predicted_price || predictions.Close.predicted || 0;
    const expectedChange = predictions.Close.expected_change || 0;
    
    const predictedPriceEl = document.getElementById('predictedPrice');
    if (predictedPriceEl) {
      predictedPriceEl.innerHTML = `
        $${predictedClose.toFixed(2)} 
        <span style="color: ${expectedChange >= 0 ? 'var(--up-color)' : 'var(--down-color)'}; font-size: 14px;">
          (${expectedChange >= 0 ? '+' : ''}${expectedChange.toFixed(2)}%)
        </span>
      `;
    }
  }

  static updateConfidence(confidence) {
    const overallConfidence = confidence.overall_confidence || 70;
    const confidenceLevel = confidence.confidence_level || "MEDIUM";
    
    const confidenceEl = document.getElementById('confidenceLevel');
    if (confidenceEl) {
      let colorClass = 'confidence-low';
      if (overallConfidence >= 80) colorClass = 'confidence-high';
      else if (overallConfidence >= 60) colorClass = 'confidence-medium';
      
      confidenceEl.textContent = `${confidenceLevel} (${Math.round(overallConfidence)}%)`;
      confidenceEl.className = `prediction-value ${colorClass}`;
    }
  }

  static updateChart(data) {
    const chartEl = document.getElementById('predictionChart');
    if (!chartEl) return;
    
    const symbol = AppState.selectedStock?.symbol || data.symbol || 'N/A';
    const currentPrice = data.current_prices?.close || 0;
    const predictedPrice = data.predictions?.Close?.predicted_price || currentPrice;
    const change = currentPrice ? ((predictedPrice - currentPrice) / currentPrice) * 100 : 0;
    
    // Create a simple bar chart visualization
    const maxVal = Math.max(currentPrice, predictedPrice) * 1.1;
    const currentHeight = (currentPrice / maxVal) * 100;
    const predictedHeight = (predictedPrice / maxVal) * 100;
    
    chartEl.innerHTML = `
      <div style="padding: 20px; height: 100%; display: flex; flex-direction: column; justify-content: space-between;">
        <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 10px;">
          ${symbol} Price Forecast
        </div>
        
        <div style="display: flex; align-items: flex-end; height: 140px; gap: 30px; padding: 0 20px;">
          <div style="display: flex; flex-direction: column; align-items: center; flex: 1;">
            <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">Current</div>
            <div style="background: linear-gradient(to top, var(--accent-blue), var(--accent-teal)); 
                        width: 40px; height: ${currentHeight}%; border-radius: 6px 6px 0 0;">
            </div>
            <div style="font-size: 12px; font-weight: 600; margin-top: 8px;">$${currentPrice.toFixed(2)}</div>
          </div>
          
          <div style="display: flex; flex-direction: column; align-items: center; flex: 1;">
            <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">Predicted</div>
            <div style="background: linear-gradient(to top, ${change >= 0 ? 'var(--up-color)' : 'var(--down-color)'}, 
                        ${change >= 0 ? 'rgba(0, 255, 157, 0.7)' : 'rgba(255, 77, 124, 0.7)'}); 
                        width: 40px; height: ${predictedHeight}%; border-radius: 6px 6px 0 0;">
            </div>
            <div style="font-size: 12px; font-weight: 600; margin-top: 8px;">$${predictedPrice.toFixed(2)}</div>
          </div>
        </div>
        
        <div style="margin-top: 20px; text-align: center; font-size: 12px; color: var(--text-muted);">
          Expected change: <span style="color: ${change >= 0 ? 'var(--up-color)' : 'var(--down-color)'}; font-weight: 600;">
            ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
          </span>
        </div>
      </div>
    `;
  }

  static updateInsight(insight) {
    const insightEl = document.getElementById('aiInsightText');
    if (insightEl) {
      insightEl.textContent = insight;
    }
  }

  static updateNextDayPredictions(predictions, currentPrices) {
    const gridEl = document.getElementById('predictionsGrid');
    const sectionEl = document.getElementById('nextDayPredictions');
    
    if (!gridEl || !sectionEl) return;
    
    const predictionTypes = [
      { key: 'Open', label: 'Open Price', icon: 'fa-door-open' },
      { key: 'High', label: 'High Price', icon: 'fa-arrow-up' },
      { key: 'Low', label: 'Low Price', icon: 'fa-arrow-down' },
      { key: 'Close', label: 'Close Price', icon: 'fa-door-closed' }
    ];
    
    gridEl.innerHTML = '';
    
    predictionTypes.forEach(type => {
      const predData = predictions[type.key];
      if (!predData) return;
      
      const predictedValue = predData.predicted_price || predData.predicted || 0;
      const currentValue = currentPrices[type.key.toLowerCase()] || currentPrices.close || predictedValue;
      const change = currentValue ? ((predictedValue - currentValue) / currentValue) * 100 : 0;
      
      const itemEl = document.createElement('div');
      itemEl.className = 'prediction-type';
      itemEl.innerHTML = `
        <div class="prediction-type-label">
          <i class="fas ${type.icon}"></i> ${type.label}
        </div>
        <div class="prediction-type-value">$${predictedValue.toFixed(2)}</div>
        <div class="prediction-type-change ${change >= 0 ? 'price-up' : 'price-down'}">
          ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
        </div>
        <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
          Conf: ${predData.confidence ? Math.round(predData.confidence) : 'â€”'}%
        </div>
      `;
      
      gridEl.appendChild(itemEl);
    });
    
    sectionEl.style.display = 'block';
  }

  static updateAlgorithmBreakdown(data) {
    const algorithmSection = document.getElementById('algorithmSection');
    const algorithmTabs = document.getElementById('algorithmTabs');
    const algorithmGrid = document.getElementById('algorithmGrid');
    
    if (!algorithmSection || !algorithmTabs || !algorithmGrid) return;
    
    const algorithmDetails = data.algorithm_predictions || data.algorithm_details || {};
    const historicalPerformance = data.historical_performance || {};
    
    // Clear existing content
    algorithmTabs.innerHTML = '';
    algorithmGrid.innerHTML = '';
    
    // Create "All" tab
    const allTab = document.createElement('div');
    allTab.className = 'algorithm-tab active';
    allTab.textContent = 'All Algorithms';
    allTab.dataset.target = 'all';
    allTab.addEventListener('click', () => {
      this.switchAlgorithmTab('all');
    });
    algorithmTabs.appendChild(allTab);
    
    // Create tabs for each algorithm
    AppState.allAlgorithms.forEach(algo => {
      const tab = document.createElement('div');
      tab.className = 'algorithm-tab';
      tab.textContent = AppState.algorithmNames[algo] || algo;
      tab.dataset.target = algo;
      tab.addEventListener('click', () => {
        this.switchAlgorithmTab(algo);
      });
      algorithmTabs.appendChild(tab);
    });
    
    // Create algorithm cards for all algorithms
    AppState.allAlgorithms.forEach(algo => {
      const algorithmCard = this.createAlgorithmCard(algo, data);
      if (algorithmCard) {
        algorithmGrid.appendChild(algorithmCard);
      }
    });
    
    // Show all algorithms by default
    algorithmSection.style.display = 'block';
    this.switchAlgorithmTab('all');
  }

  static createAlgorithmCard(algorithm, data) {
    const card = document.createElement('div');
    card.className = 'algorithm-card';
    card.dataset.algorithm = algorithm;
    
    const algoName = AppState.algorithmNames[algorithm] || algorithm;
    const algorithmColor = AppState.algorithmColors[algorithm] || 'var(--accent-blue)';
    
    // Get predictions for this algorithm
    const algorithmDetails = data.algorithm_predictions || {};
    const historicalPerformance = data.historical_performance || {};
    const currentPrices = data.current_prices || {};
    
    // Collect predictions from all targets
    const predictions = {};
    let totalConfidence = 0;
    let confidenceCount = 0;
    
    ['Open', 'High', 'Low', 'Close'].forEach(target => {
      if (algorithmDetails[target] && algorithmDetails[target].individual) {
        const individualPreds = algorithmDetails[target].individual;
        if (individualPreds[algorithm]) {
          predictions[target] = {
            value: individualPreds[algorithm],
            confidence: algorithmDetails[target].confidences?.[algorithm] || 50
          };
          totalConfidence += predictions[target].confidence;
          confidenceCount++;
        }
      }
    });
    
    // Calculate average confidence
    const avgConfidence = confidenceCount > 0 ? totalConfidence / confidenceCount : 50;
    
    // Determine confidence class
    let confidenceClass = 'low';
    if (avgConfidence >= 80) confidenceClass = 'high';
    else if (avgConfidence >= 60) confidenceClass = 'medium';
    
    // Get performance metrics
    const performance = {};
    ['Open', 'High', 'Low', 'Close'].forEach(target => {
      if (historicalPerformance[target] && historicalPerformance[target][algorithm]) {
        performance[target] = historicalPerformance[target][algorithm];
      }
    });
    
    // Calculate overall performance score
    let performanceScore = 0;
    let perfCount = 0;
    Object.values(performance).forEach(perf => {
      if (perf) {
        const r2Score = Math.max(perf.r2 || 0, 0);
        const dirAcc = perf.direction_accuracy || 0;
        performanceScore += (r2Score * 100 * 0.5) + (dirAcc * 0.5);
        perfCount++;
      }
    });
    performanceScore = perfCount > 0 ? performanceScore / perfCount : 0;
    
    // Create card content
    card.innerHTML = `
      <div class="algorithm-card-header">
        <div class="algorithm-name" style="color: ${algorithmColor}">
          ${algoName}
        </div>
        <div class="algorithm-confidence ${confidenceClass}">
          ${Math.round(avgConfidence)}%
        </div>
      </div>
      
      <div class="algorithm-predictions">
    `;
    
    // Add prediction items
    ['Open', 'High', 'Low', 'Close'].forEach(target => {
      const pred = predictions[target];
      const currentValue = currentPrices[target.toLowerCase()] || currentPrices.close || 0;
      
      let predValue = 0;
      let confidence = 0;
      let change = 0;
      
      if (pred) {
        predValue = pred.value;
        confidence = pred.confidence;
        change = currentValue ? ((predValue - currentValue) / currentValue) * 100 : 0;
      } else {
        // Fallback to ensemble prediction
        const ensemblePred = data.predictions?.[target]?.predicted_price || currentValue;
        predValue = ensemblePred;
        change = currentValue ? ((predValue - currentValue) / currentValue) * 100 : 0;
        confidence = 50;
      }
      
      const predictionItem = document.createElement('div');
      predictionItem.className = 'algorithm-prediction-item';
      predictionItem.innerHTML = `
        <div class="algorithm-prediction-label">${target}</div>
        <div class="algorithm-prediction-value">$${predValue.toFixed(2)}</div>
        <div class="algorithm-prediction-change ${change >= 0 ? 'price-up' : 'price-down'}">
          ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
        </div>
        <div style="font-size:10px;color:var(--text-muted)">
          Conf: ${Math.round(confidence)}%
        </div>
      `;
      
      card.querySelector('.algorithm-predictions').appendChild(predictionItem);
    });
    
    // Close predictions container
    card.innerHTML += `</div>`;
    
    // Add performance metrics
    if (Object.keys(performance).length > 0) {
      card.innerHTML += `
        <div class="algorithm-performance">
          <div class="algorithm-performance-grid">
      `;
      
      ['Open', 'High', 'Low', 'Close'].forEach(target => {
        const perf = performance[target];
        if (perf) {
          card.innerHTML += `
            <div class="algorithm-performance-item">
              <div class="algorithm-performance-label">${target} RÂ²</div>
              <div class="algorithm-performance-value">${perf.r2 ? perf.r2.toFixed(3) : 'â€”'}</div>
            </div>
          `;
        }
      });
      
      card.innerHTML += `</div></div>`;
    }
    
    // Add border color based on algorithm
    card.style.borderLeft = `3px solid ${algorithmColor}`;
    
    return card;
  }

  static switchAlgorithmTab(algorithm) {
    AppState.activeAlgorithmTab = algorithm;
    
    // Update active tab
    document.querySelectorAll('.algorithm-tab').forEach(tab => {
      if (tab.dataset.target === algorithm) {
        tab.classList.add('active');
      } else {
        tab.classList.remove('active');
      }
    });
    
    // Show/hide algorithm cards
    document.querySelectorAll('.algorithm-card').forEach(card => {
      if (algorithm === 'all' || card.dataset.algorithm === algorithm) {
        card.style.display = 'block';
      } else {
        card.style.display = 'none';
      }
    });
  }

  static updateModelComparison(data) {
    const tableBody = document.getElementById('modelComparisonBody');
    const tableHeader = document.getElementById('modelComparisonHeader');
    const section = document.getElementById('modelComparisonSection');
    
    if (!tableBody || !tableHeader) return;
    
    const historicalPerformance = data.historical_performance || {};
    const algorithmWeights = data.model_info?.algorithm_weights || {};
    const algorithmDetails = data.algorithm_predictions || {};
    
    // Clear table
    tableBody.innerHTML = '';
    
    // Create header
    tableHeader.innerHTML = `
      <th>Model</th>
      <th>Performance Score</th>
      <th>Avg RÂ²</th>
      <th>Avg Direction Acc</th>
      <th>Avg MAPE</th>
      <th>Weight</th>
      <th>Status</th>
    `;
    
    // Calculate scores for each algorithm
    const algorithmScores = [];
    
    AppState.allAlgorithms.forEach(algo => {
      let totalR2 = 0;
      let totalDirAcc = 0;
      let totalMape = 0;
      let count = 0;
      
      ['Open', 'High', 'Low', 'Close'].forEach(target => {
        if (historicalPerformance[target] && historicalPerformance[target][algo]) {
          const perf = historicalPerformance[target][algo];
          totalR2 += perf.r2 || 0;
          totalDirAcc += perf.direction_accuracy || 0;
          totalMape += perf.mape || 0;
          count++;
        }
      });
      
      if (count > 0) {
        const avgR2 = totalR2 / count;
        const avgDirAcc = totalDirAcc / count;
        const avgMape = totalMape / count;
        
        // Calculate performance score (weighted average)
        const performanceScore = (
          (Math.max(avgR2, 0) * 100 * 0.4) + 
          (avgDirAcc * 0.4) + 
          ((100 - Math.min(avgMape, 100)) * 0.2)
        );
        
        algorithmScores.push({
          algorithm: algo,
          name: AppState.algorithmNames[algo],
          performanceScore: performanceScore,
          avgR2: avgR2,
          avgDirAcc: avgDirAcc,
          avgMape: avgMape,
          weight: algorithmWeights.Close?.[algo] || 0.1,
          isActive: count > 0
        });
      }
    });
    
    // Sort by performance score
    algorithmScores.sort((a, b) => b.performanceScore - a.performanceScore);
    
    // Add rows to table
    algorithmScores.forEach((score, index) => {
      const row = document.createElement('tr');
      
      let rankBadge = '';
      if (index === 0) rankBadge = '<span class="rank-badge rank-1">ðŸ¥‡ Best</span>';
      else if (index === 1) rankBadge = '<span class="rank-badge rank-2">ðŸ¥ˆ 2nd</span>';
      else if (index === 2) rankBadge = '<span class="rank-badge rank-3">ðŸ¥‰ 3rd</span>';
      
      const status = score.isActive ? 
        '<span style="color: var(--up-color);">âœ… Active</span>' : 
        '<span style="color: var(--text-muted);">âš ï¸ Limited</span>';
      
      row.innerHTML = `
        <td class="model-name" style="color: ${AppState.algorithmColors[score.algorithm] || 'var(--text-primary)'}">
          ${score.name} ${rankBadge}
        </td>
        <td class="performance-score">${score.performanceScore.toFixed(1)}</td>
        <td>${score.avgR2.toFixed(3)}</td>
        <td>${score.avgDirAcc.toFixed(1)}%</td>
        <td>${score.avgMape.toFixed(1)}%</td>
        <td>${score.weight.toFixed(2)}</td>
        <td>${status}</td>
      `;
      
      tableBody.appendChild(row);
    });
    
    section.style.display = 'block';
  }

  static updateDetailedModelViews(data) {
    const section = document.getElementById('detailedModelSection');
    if (!section) return;
    
    const historicalPerformance = data.historical_performance || {};
    const algorithmDetails = data.algorithm_predictions || {};
    const currentPrices = data.current_prices || {};
    
    section.innerHTML = '';
    
    // Create detailed cards for top 3 models
    const modelScores = [];
    
    AppState.allAlgorithms.forEach(algo => {
      let totalR2 = 0;
      let count = 0;
      
      ['Open', 'High', 'Low', 'Close'].forEach(target => {
        if (historicalPerformance[target] && historicalPerformance[target][algo]) {
          totalR2 += historicalPerformance[target][algo].r2 || 0;
          count++;
        }
      });
      
      if (count > 0) {
        modelScores.push({
          algorithm: algo,
          avgR2: totalR2 / count
        });
      }
    });
    
    // Sort by RÂ² score and take top 3
    modelScores.sort((a, b) => b.avgR2 - a.avgR2);
    const topModels = modelScores.slice(0, 3);
    
    topModels.forEach((model, index) => {
      const algo = model.algorithm;
      const algoName = AppState.algorithmNames[algo];
      const algorithmColor = AppState.algorithmColors[algo];
      
      const card = document.createElement('div');
      card.className = 'detailed-model-card';
      card.style.borderLeft = `4px solid ${algorithmColor}`;
      
      // Get predictions for this model
      const predictions = {};
      ['Open', 'High', 'Low', 'Close'].forEach(target => {
        if (algorithmDetails[target] && algorithmDetails[target].individual) {
          predictions[target] = algorithmDetails[target].individual[algo] || 0;
        }
      });
      
      // Get performance metrics
      const perfMetrics = {};
      ['Open', 'High', 'Low', 'Close'].forEach(target => {
        if (historicalPerformance[target] && historicalPerformance[target][algo]) {
          perfMetrics[target] = historicalPerformance[target][algo];
        }
      });
      
      // Calculate average metrics
      let avgR2 = 0, avgDirAcc = 0, avgMape = 0, perfCount = 0;
      Object.values(perfMetrics).forEach(perf => {
        avgR2 += perf.r2 || 0;
        avgDirAcc += perf.direction_accuracy || 0;
        avgMape += perf.mape || 0;
        perfCount++;
      });
      
      if (perfCount > 0) {
        avgR2 /= perfCount;
        avgDirAcc /= perfCount;
        avgMape /= perfCount;
      }
      
      const rankIcons = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
      
      card.innerHTML = `
        <div class="detailed-model-header">
          <div class="detailed-model-title" style="color: ${algorithmColor}">
            ${rankIcons[index]} ${algoName}
          </div>
          <div style="font-size: 12px; color: var(--text-muted);">
            Rank #${index + 1}
          </div>
        </div>
        
        <div class="detailed-model-stats">
          <div class="detailed-model-stat">
            <div class="detailed-model-stat-label">Avg RÂ² Score</div>
            <div class="detailed-model-stat-value">${avgR2.toFixed(3)}</div>
          </div>
          <div class="detailed-model-stat">
            <div class="detailed-model-stat-label">Direction Accuracy</div>
            <div class="detailed-model-stat-value">${avgDirAcc.toFixed(1)}%</div>
          </div>
          <div class="detailed-model-stat">
            <div class="detailed-model-stat-label">Avg MAPE</div>
            <div class="detailed-model-stat-value">${avgMape.toFixed(1)}%</div>
          </div>
          <div class="detailed-model-stat">
            <div class="detailed-model-stat-label">Weight in Ensemble</div>
            <div class="detailed-model-stat-value">${data.model_info?.algorithm_weights?.Close?.[algo]?.toFixed(2) || '0.10'}</div>
          </div>
        </div>
        
        <div style="margin-bottom: 16px;">
          <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
            Next Day Predictions:
          </div>
          <div class="detailed-model-predictions">
      `;
      
      ['Open', 'High', 'Low', 'Close'].forEach(target => {
        const predValue = predictions[target] || 0;
        const currentValue = currentPrices[target.toLowerCase()] || 0;
        const change = currentValue ? ((predValue - currentValue) / currentValue) * 100 : 0;
        
        card.innerHTML += `
          <div class="detailed-model-prediction">
            <div class="detailed-model-prediction-label">${target}</div>
            <div class="detailed-model-prediction-value">$${predValue.toFixed(2)}</div>
            <div style="font-size: 11px; color: ${change >= 0 ? 'var(--up-color)' : 'var(--down-color)'}">
              ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
            </div>
          </div>
        `;
      });
      
      card.innerHTML += `</div></div>`;
      
      section.appendChild(card);
    });
    
    section.style.display = 'grid';
  }

  static hideNextDayPredictions() {
    const sectionEl = document.getElementById('nextDayPredictions');
    if (sectionEl) {
      sectionEl.style.display = 'none';
    }
  }

  static hideAlgorithmSection() {
    const sectionEl = document.getElementById('algorithmSection');
    if (sectionEl) {
      sectionEl.style.display = 'none';
    }
  }

  static updatePerformance(performance) {
    if (!performance || !performance.Close) return;
    
    // Calculate best performance across all algorithms
    let bestR2 = 0;
    let bestDirAcc = 0;
    let bestRMSE = Infinity;
    let activeAlgorithms = 0;
    
    Object.values(performance).forEach(targetPerf => {
      if (targetPerf) {
        Object.values(targetPerf).forEach(algoPerf => {
          if (algoPerf) {
            bestR2 = Math.max(bestR2, algoPerf.r2 || 0);
            bestDirAcc = Math.max(bestDirAcc, algoPerf.direction_accuracy || 0);
            bestRMSE = Math.min(bestRMSE, algoPerf.rmse || Infinity);
            activeAlgorithms++;
          }
        });
      }
    });
    
    // Count unique algorithms
    const uniqueAlgorithms = new Set();
    Object.values(performance).forEach(targetPerf => {
      if (targetPerf) {
        Object.keys(targetPerf).forEach(algo => {
          uniqueAlgorithms.add(algo);
        });
      }
    });
    
    document.getElementById('r2Score').textContent = bestR2.toFixed(3);
    document.getElementById('directionAccuracy').textContent = `${bestDirAcc.toFixed(1)}%`;
    document.getElementById('rmseScore').textContent = bestRMSE !== Infinity ? bestRMSE.toFixed(4) : 'â€”';
    document.getElementById('algorithmsUsed').textContent = uniqueAlgorithms.size;
  }

  static resetPerformance() {
    const ids = ['r2Score', 'directionAccuracy', 'rmseScore', 'algorithmsUsed'];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.textContent = 'â€”';
    });
  }

  static updateConfidenceBars(predictions) {
    const targets = ['Open', 'High', 'Low', 'Close'];
    const colors = [
      'var(--accent-blue)',
      'var(--accent-teal)',
      'var(--accent-purple)',
      'var(--up-color)'
    ];
    
    targets.forEach((target, index) => {
      const predData = predictions[target];
      if (!predData) return;
      
      const confidence = predData.confidence || 50;
      const barEl = document.querySelector(`.confidence-bar:nth-child(${index + 1}) .confidence-fill`);
      const valueEl = document.querySelector(`.confidence-bar:nth-child(${index + 1}) .confidence-value`);
      
      if (barEl && valueEl) {
        barEl.style.width = `${confidence}%`;
        barEl.style.background = colors[index];
        valueEl.textContent = `${Math.round(confidence)}%`;
      }
    });
  }

  static updateCrisisDetection(data) {
    const crisisProbability = data.risk_metrics?.volatility ? Math.min(data.risk_metrics.volatility / 50, 1) * 100 : 10;
    const riskLevel = data.risk_level || "ðŸŸ¢ LOW RISK";
    
    // Update crisis card
    const crisisCard = document.getElementById('crisisCard');
    const crisisProbabilityEl = document.getElementById('crisisProbability');
    const crisisDescriptionEl = document.getElementById('crisisDescription');
    
    let crisisClass = 'normal';
    let crisisIcon = 'fa-check-circle';
    let iconColor = 'var(--normal-green)';
    let description = 'Market conditions appear stable with normal volatility levels.';
    
    if (crisisProbability > 70) {
      crisisClass = 'critical';
      crisisIcon = 'fa-exclamation-triangle';
      iconColor = 'var(--crisis-red)';
      description = 'High probability of market stress detected. Exercise extreme caution.';
    } else if (crisisProbability > 40) {
      crisisClass = 'warning';
      crisisIcon = 'fa-exclamation-circle';
      iconColor = 'var(--warning-orange)';
      description = 'Elevated market risk detected. Monitor positions closely.';
    }
    
    crisisCard.className = `crisis-card ${crisisClass}`;
    crisisCard.querySelector('.crisis-icon').className = `fas ${crisisIcon} crisis-icon`;
    crisisCard.querySelector('.crisis-icon').style.color = iconColor;
    
    crisisProbabilityEl.textContent = `${crisisProbability.toFixed(1)}%`;
    crisisDescriptionEl.textContent = description;
    
    // Update regime card
    const regimeCard = document.getElementById('regimeCard');
    const regimeLevelEl = document.getElementById('regimeLevel');
    
    // Determine market regime from risk metrics
    const volatility = data.risk_metrics?.volatility || 0;
    const anomalyScore = data.risk_metrics?.anomaly_score || 0;
    
    let regime = 'NORMAL';
    if (volatility > 40) regime = 'HIGH_VOLATILITY';
    else if (anomalyScore > 30) regime = 'ELEVATED_RISK';
    
    regimeLevelEl.textContent = regime;
    regimeCard.className = `crisis-card ${crisisClass}`;
    
    // Update regime indicators
    this.updateRegimeIndicators(regime, data.risk_metrics || {});
  }

  static updateRegimeIndicators(regime, riskMetrics) {
    const indicators = {
      volatility: document.getElementById('volatilityIndicator'),
      momentum: document.getElementById('momentumIndicator'),
      volume: document.getElementById('volumeIndicator'),
      sentiment: document.getElementById('sentimentIndicator')
    };
    
    const volatilityValue = riskMetrics.volatility || 0;
    const skewness = riskMetrics.skewness || 0;
    const positiveDays = riskMetrics.positive_days || 50;
    
    // Set indicator text based on metrics
    if (indicators.volatility) {
      let volText = 'Volatility: ';
      if (volatilityValue > 40) volText += 'Very High';
      else if (volatilityValue > 20) volText += 'High';
      else if (volatilityValue > 10) volText += 'Moderate';
      else volText += 'Low';
      indicators.volatility.textContent = volText;
    }
    
    if (indicators.momentum) {
      let momText = 'Momentum: ';
      if (skewness > 0.5) momText += 'Bullish';
      else if (skewness < -0.5) momText += 'Bearish';
      else momText += 'Neutral';
      indicators.momentum.textContent = momText;
    }
    
    if (indicators.volume) {
      indicators.volume.textContent = 'Volume: Standard';
    }
    
    if (indicators.sentiment) {
      let sentText = 'Sentiment: ';
      if (positiveDays > 60) sentText += 'Bullish';
      else if (positiveDays < 40) sentText += 'Bearish';
      else sentText += 'Neutral';
      indicators.sentiment.textContent = sentText;
    }
  }

  static resetCrisisDetection() {
    const crisisCard = document.getElementById('crisisCard');
    const regimeCard = document.getElementById('regimeCard');
    
    if (crisisCard) crisisCard.className = 'crisis-card normal';
    if (regimeCard) regimeCard.className = 'crisis-card normal';
    
    document.getElementById('crisisProbability').textContent = '10%';
    document.getElementById('regimeLevel').textContent = 'NORMAL';
    
    // Reset indicators
    this.updateRegimeIndicators('NORMAL', {});
  }

  static updateRiskAlerts(alerts) {
    const alertListEl = document.getElementById('alertList');
    const riskAlertsSection = document.getElementById('riskAlerts');
    
    if (!alertListEl || !riskAlertsSection) return;
    
    if (!alerts || alerts.length === 0) {
      riskAlertsSection.style.display = 'none';
      return;
    }
    
    alertListEl.innerHTML = '';
    
    alerts.forEach(alert => {
      const alertItem = document.createElement('div');
      
      let alertClass = 'info';
      let icon = 'fa-info-circle';
      
      if (alert.level.includes('ðŸ”´') || alert.level.includes('CRITICAL')) {
        alertClass = 'critical';
        icon = 'fa-exclamation-triangle';
      } else if (alert.level.includes('ðŸŸ¡') || alert.level.includes('HIGH')) {
        alertClass = 'warning';
        icon = 'fa-exclamation-circle';
      }
      
      alertItem.className = `alert-item ${alertClass}`;
      alertItem.innerHTML = `
        <i class="fas ${icon} alert-icon"></i>
        <div class="alert-content">
          <div class="alert-level">${alert.level || 'âš ï¸ ALERT'} ${alert.type || 'Risk Alert'}</div>
          <div class="alert-message">${alert.message || 'Risk condition detected'}</div>
          <div class="alert-action">${alert.details || 'Monitor closely'}</div>
        </div>
      `;
      
      alertListEl.appendChild(alertItem);
    });
    
    riskAlertsSection.style.display = 'block';
  }

  static hideRiskAlerts() {
    const riskAlertsSection = document.getElementById('riskAlerts');
    if (riskAlertsSection) {
      riskAlertsSection.style.display = 'none';
    }
  }

  static updateMetrics(data) {
    // Update accuracy metric
    const performance = data.historical_performance?.Close;
    if (performance) {
      const algorithms = Object.keys(performance);
      let totalAccuracy = 0;
      algorithms.forEach(algo => {
        totalAccuracy += performance[algo].direction_accuracy || 0;
      });
      const avgAccuracy = algorithms.length > 0 ? totalAccuracy / algorithms.length : 0;
      document.getElementById('metricAccuracy').textContent = `${avgAccuracy.toFixed(1)}%`;
    }
    
    // Update profitable predictions
    const positiveDays = data.risk_metrics?.positive_days || 50;
    document.getElementById('metricProfit').textContent = `${positiveDays.toFixed(1)}%`;
    
    // Update latency
    if (AppState.lastFetchTime) {
      const now = new Date();
      const latency = Math.round((now - AppState.lastFetchTime) / 1000);
      document.getElementById('metricLatency').textContent = `${latency}s`;
    }
    
    // Update history
    const totalDays = data.data_info?.total_days || 0;
    document.getElementById('metricHistory').textContent = `${totalDays} days`;
  }

  static resetMetrics() {
    const metricIds = ['metricAccuracy', 'metricProfit', 'metricLatency', 'metricHistory'];
    metricIds.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.textContent = 'â€”';
    });
  }

  static updateRiskAndRecommendation(data) {
    const riskLevel = data.risk_level || "ðŸŸ¢ LOW RISK";
    const recommendation = data.trading_recommendation || "ðŸ”„ HOLD";
    
    // You can add DOM elements to display these if needed
    console.log(`Risk Level: ${riskLevel}, Recommendation: ${recommendation}`);
  }
}

/* Prediction Manager */
class PredictionManager {
  static async generate() {
    if (!AppState.selectedStock) {
      NotificationManager.show('Please select a stock first', 'error');
      return;
    }
    
    if (AppState.isGenerating) return;
    
    AppState.isGenerating = true;
    this.updateButtons(true);
    
    const symbol = AppState.selectedStock.symbol;
    
    try {
      NotificationManager.show(`Generating predictions for ${symbol} with 8 algorithms...`, 'success');
      
      // Show loading state
      const chartEl = document.getElementById('predictionChart');
      if (chartEl) {
        chartEl.innerHTML = `
          <div style="padding: 40px; text-align: center; color: var(--text-muted);">
            <i class="fas fa-spinner fa-spin" style="font-size: 36px; margin-bottom: 16px;"></i>
            <div>AI is analyzing ${symbol} with 8 algorithms...</div>
            <div style="font-size: 12px; margin-top: 8px;">Processing 10 years of data with 90+ features</div>
            <div style="font-size: 10px; margin-top: 4px;">Algorithms: Linear, Ridge, Lasso, SVR, RF, GB, ARIMA, NN</div>
          </div>
        `;
      }
      
      // Fetch prediction from Flask API
      const data = await StockAPIService.predict(symbol);
      
      // Update display with prediction data
      PredictionDisplay.update(data);
      
      NotificationManager.show(`Predictions ready for ${symbol}. 8 algorithms analyzed.`, 'success');
      
    } catch (err) {
      console.error('Prediction generation error:', err);
      NotificationManager.show(`Prediction failed: ${err.message}`, 'error');
      
      // Show error in chart
      const chartEl = document.getElementById('predictionChart');
      if (chartEl) {
        chartEl.innerHTML = `
          <div style="padding: 40px; text-align: center; color: var(--down-color);">
            <i class="fas fa-exclamation-triangle" style="font-size: 36px; margin-bottom: 16px;"></i>
            <div>Prediction failed</div>
            <div style="font-size: 12px; margin-top: 8px;">${err.message}</div>
          </div>
        `;
      }
    } finally {
      AppState.isGenerating = false;
      this.updateButtons(false);
    }
  }

  static async trainModels() {
    if (!AppState.selectedStock) {
      NotificationManager.show('Please select a stock first', 'error');
      return;
    }
    
    const symbol = AppState.selectedStock.symbol;
    
    try {
      NotificationManager.show(`Training all 8 models for ${symbol}...`, 'success');
      const result = await StockAPIService.trainModels(symbol);
      
      if (result.status === 'success') {
        NotificationManager.show(`All 8 models trained successfully for ${symbol}`, 'success');
        
        // Refresh predictions after training
        setTimeout(() => this.generate(), 1000);
      } else {
        NotificationManager.show(`Training failed: ${result.message}`, 'error');
      }
    } catch (err) {
      console.error('Training error:', err);
      NotificationManager.show(`Training failed: ${err.message}`, 'error');
    }
  }

  static async refresh() {
    if (!AppState.selectedStock || AppState.isGenerating) return;
    await this.generate();
  }

  static async generateAll() {
    if (AppState.isGenerating) return;
    
    AppState.isGenerating = true;
    this.updateButtons(true);
    
    const generateAllBtn = document.getElementById('generateAllBtn');
    if (generateAllBtn) {
      generateAllBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating All...';
    }
    
    NotificationManager.show('Generating predictions for all stocks with 8 algorithms...', 'success');
    
    try {
      // Limit to first 3 stocks to avoid overwhelming the server
      const stocksToProcess = AppState.allStocks.slice(0, 3);
      
      for (const stock of stocksToProcess) {
        try {
          AppState.selectedStock = stock;
          await StockAPIService.predict(stock.symbol);
          console.log(`Generated prediction for ${stock.symbol}`);
        } catch (err) {
          console.warn(`Failed to generate for ${stock.symbol}:`, err);
        }
        
        // Small delay between requests
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      // Restore original selection
      if (AppState.selectedStock) {
        await StockAPIService.predict(AppState.selectedStock.symbol);
      }
      
      NotificationManager.show('Batch generation complete with 8 algorithms per stock', 'success');
    } catch (err) {
      console.error('Batch generation error:', err);
      NotificationManager.show('Batch generation partially failed', 'error');
    } finally {
      AppState.isGenerating = false;
      this.updateButtons(false);
      
      if (generateAllBtn) {
        generateAllBtn.innerHTML = '<i class="fas fa-bolt"></i> Generate All';
      }
    }
  }

  static updateButtons(isLoading) {
    const buttons = {
      'predictBtn': '<i class="fas fa-chart-line"></i> Predict',
      'refreshBtn': '<i class="fas fa-sync-alt"></i> Refresh',
      'generateAllBtn': '<i class="fas fa-bolt"></i> Generate All',
      'trainBtn': '<i class="fas fa-brain"></i> Train'
    };
    
    Object.keys(buttons).forEach(id => {
      const btn = document.getElementById(id);
      if (btn) {
        btn.disabled = isLoading;
        if (isLoading && id === 'predictBtn') {
          btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Predicting...';
        } else if (isLoading && id === 'generateAllBtn') {
          btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
        } else if (isLoading && id === 'trainBtn') {
          btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Training...';
        } else {
          btn.innerHTML = buttons[id];
        }
      }
    });
  }
}

/* Theme Manager */
class ThemeManager {
  static toggle() {
    document.body.classList.toggle('light');
    localStorage.setItem('theme', document.body.classList.contains('light') ? 'light' : 'dark');
  }

  static load() {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {
      document.body.classList.add('light');
    }
  }
}

/* Initialize Application */
let stockListManager;

document.addEventListener('DOMContentLoaded', async () => {
  console.log('Initializing Stock Prediction App with 8-Algorithm Support...');
  
  // Initialize components
  ThemeManager.load();
  new MobileMenu();
  
  // Initialize stock list manager
  stockListManager = new StockListManager();
  await stockListManager.populate();
  
  // Set up event listeners
  this.setupEventListeners();
  
  // Auto-refresh stocks periodically
  this.setupAutoRefresh();
  
  console.log('App initialized with 8-algorithm prediction system');
});

function setupEventListeners() {
  // Prediction buttons
  document.getElementById('predictBtn').addEventListener('click', () => PredictionManager.generate());
  document.getElementById('refreshBtn').addEventListener('click', () => PredictionManager.refresh());
  document.getElementById('generateAllBtn').addEventListener('click', () => PredictionManager.generateAll());
  document.getElementById('trainBtn').addEventListener('click', () => PredictionManager.trainModels());
  
  // Theme toggle
  document.getElementById('themeBtn').addEventListener('click', () => ThemeManager.toggle());
  
  // Global search
  const globalSearch = document.getElementById('globalSearch');
  if (globalSearch) {
    globalSearch.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      console.log('Searching for:', query);
    });
  }
  
  // Stock search with Enter key
  const stockSearch = document.getElementById('stockSearch');
  if (stockSearch) {
    stockSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const query = e.target.value.trim().toUpperCase();
        const foundStock = AppState.allStocks.find(stock => 
          stock.symbol.toUpperCase() === query || 
          stock.name.toUpperCase().includes(query)
        );
        
        if (foundStock) {
          stockListManager.select(foundStock);
          stockSearch.value = '';
        } else {
          NotificationManager.show(`Stock "${query}" not found`, 'error');
        }
      }
    });
  }
  
  // History range selector
  const historyRange = document.getElementById('historyRange');
  if (historyRange) {
    historyRange.addEventListener('change', (e) => {
      console.log('History range changed to:', e.target.value);
    });
  }
  
  // Model comparison filter
  const modelComparisonFilter = document.getElementById('modelComparisonFilter');
  if (modelComparisonFilter) {
    modelComparisonFilter.addEventListener('change', (e) => {
      console.log('Model comparison filter changed to:', e.target.value);
    });
  }
}

function setupAutoRefresh() {
  // Refresh stock list every 5 minutes
  setInterval(async () => {
    if (!AppState.isGenerating) {
      const previousCount = AppState.allStocks.length;
      AppState.allStocks = await StockAPIService.fetchStocks();
      stockListManager.render();
      
      if (AppState.allStocks.length !== previousCount) {
        console.log(`Stock list refreshed: ${AppState.allStocks.length} stocks`);
      }
    }
  }, CONFIG.STOCK_REFRESH_INTERVAL);
}

/* Global error handler */
window.addEventListener('error', (event) => {
  console.error('Global error:', event.error || event.message);
  NotificationManager.show('An unexpected error occurred', 'error');
});

/* Unhandled promise rejection handler */
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  NotificationManager.show('A background operation failed', 'error');
});
</script>
</body>
</html>